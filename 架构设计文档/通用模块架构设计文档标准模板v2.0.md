# 通用模块架构设计文档标准模板 v2.0

> **基于UNIVERSAL_COMPONENT_ARCHITECTURE_CORE v2.5标准**  
> **完整前后端一体化 + 层级化页面组架构 + 八段式代码规范**

---

## 📋 文档信息

- **模块名称**：{模块名称}（如：消息模块、发现模块）
- **页面类型**：{页面类型描述}
- **设计标准**：UNIVERSAL_COMPONENT_ARCHITECTURE_CORE v2.5
- **创建日期**：{日期}
- **版本号**：v2.0
- **适用项目**：{项目名称}

---

## 🎯 核心设计原则遵循检查清单

### ✅ 架构标准强制执行项

- [ ] **层级化页面组主导架构** - MainPage + SubPages结构
- [ ] **前后端一体化强制实施** - API层与后端实现层同时完整交付
- [ ] **MyBatis-Plus标准架构** - QueryWrapper/LambdaQueryWrapper查询
- [ ] **八段式代码结构** - 所有主文件遵循八段式规范
- [ ] **主文件优先原则** - 状态/事件/数据处理集中在主文件内
- [ ] **按需设计原则** - 仅创建前端实际需要的接口
- [ ] **类型安全** - 完整的TypeScript类型定义
- [ ] **常量规范** - 所有常量在constants.[ext]中定义

---

## 📦 一、模块架构总览

### 1.1 页面组层级结构

```
src/pages/{ModuleName}/                    # 📦 模块页面组
├── index.[ext]                             # 🎯 页面组主文件 - 状态管理、导航协调
├── types.[ext]                             # 📋 页面组类型定义
├── constants.[ext]                         # ⚙️ 页面组常量配置
├── README.md                               # 📖 页面组文档
│
├── MainPage/                               # 🏠 主页面
│   ├── index.[ext]                         # 主页面实现
│   ├── types.[ext]                         # 主页面类型
│   ├── constants.[ext]                     # 主页面常量
│   ├── README.md                           # 主页面文档
│   │
│   ├── {ComponentAreaName1}/               # ✅ 页面组成区域组件1
│   │   ├── index.[ext]                     # 🎯 区域组件主文件（八段式）
│   │   ├── types.[ext]                     # 区域类型定义（可选）
│   │   ├── constants.[ext]                 # 区域常量（可选）
│   │   └── README.md                       # 区域文档
│   │
│   ├── {ComponentAreaName2}/               # ✅ 页面组成区域组件2
│   └── {ComponentAreaName3}/               # ✅ 页面组成区域组件3
│
├── {SubFunction1}Page/                     # 📄 子功能页面1
│   ├── index.[ext]
│   ├── types.[ext]
│   ├── constants.[ext]
│   ├── README.md
│   ├── {ComponentAreaName1}/               # 子页面区域组件1
│   └── {ComponentAreaName2}/               # 子页面区域组件2
│
├── {SubFunction2}Page/                     # 📄 子功能页面2
├── {SubFunction3}Page/                     # 📄 子功能页面3
│
├── 🌐 API接口层（前端）
│   ├── api{ModuleName}Main.[ext]           # 主页面API
│   ├── api{ModuleName}{SubFunction1}.[ext] # 子功能1 API
│   ├── api{ModuleName}{SubFunction2}.[ext] # 子功能2 API
│   └── api{ModuleName}Aggregate.[ext]      # 聚合API（可选）
│
└── 🔌 后端交互层（Java/Kotlin）
    └── backend/
        ├── entity{ModuleName}.[ext]        # 🏗️ 数据实体（MyBatis-Plus）
        ├── dto{ModuleName}{Action}.[ext]   # 📦 数据传输对象
        ├── vo{ModuleName}Query.[ext]       # 🔍 查询视图对象（可选）
        ├── controller{ModuleName}.[ext]    # 🎯 控制器
        ├── service{ModuleName}.[ext]       # ⚙️ 服务接口
        ├── serviceImpl{ModuleName}.[ext]   # 🔧 服务实现（QueryWrapper）
        ├── mapper{ModuleName}.[ext]        # 🗄️ Mapper接口
        ├── query{ModuleName}Builder.[ext]  # 🏗️ 查询构建器（可选）
        └── sql{ModuleName}.xml             # 📝 复杂SQL（可选）
```

### 1.2 页面层级说明

| 层级 | 命名规范 | 职责 | 示例 |
|------|---------|------|------|
| **页面组** | `{ModuleName}/` | 完整业务模块 | `Message/`, `Discovery/` |
| **主页面** | `MainPage/` | 模块主入口 | 固定命名 |
| **子页面** | `{SubFunction}Page/` | 子功能页面 | `DetailPage/`, `SettingsPage/` |
| **区域组件** | `{ComponentAreaName}/` | 页面功能区域 | `HeaderArea/`, `ContentArea/` |

---

## 📋 二、核心类型定义（types.[ext]）

### 2.1 页面组级别类型

```typescript
// 页面组Props接口
export interface {ModuleName}Props {
  // 页面组属性定义
}

// 页面组状态类型
export interface {ModuleName}State {
  // 状态属性定义
}
```

### 2.2 数据实体类型

```typescript
// 核心实体类型定义
export interface {EntityName} {
  id: string;
  // 实体属性...
  createdAt: number;
  updatedAt: number;
}

// 列表响应类型
export interface {EntityName}ListResponse {
  list: {EntityName}[];
  total: number;
  hasMore: boolean;
}
```

### 2.3 API交互类型

```typescript
// API请求参数类型
export interface {Action}Request {
  // 请求参数...
}

// API响应类型
export interface ApiResponse<T> {
  code: number;
  message: string;
  data: T;
}

// 分页查询参数
export interface PageQuery {
  page: number;
  pageSize: number;
}
```

### 2.4 组件Props类型

```typescript
// 区域组件Props
export interface {ComponentAreaName}Props {
  // 组件属性...
}

// 事件回调类型
export type {Action}Callback = (params: any) => void;
```

---

## ⚙️ 三、常量配置（constants.[ext]）

### 3.1 UI尺寸常量

```typescript
export const UI_SIZES = {
  SYSTEM_STATUS_BAR_HEIGHT: 44,
  NAVIGATION_BAR_HEIGHT: 56,
  BOTTOM_TAB_BAR_HEIGHT: 80,
  SAFE_AREA_BOTTOM: 34,
  // 其他尺寸常量...
} as const;
```

### 3.2 颜色常量

```typescript
export const COLORS = {
  PRIMARY: '#8A2BE2',
  TEXT_PRIMARY: '#000000',
  TEXT_SECONDARY: '#999999',
  BACKGROUND_WHITE: '#FFFFFF',
  // 其他颜色常量...
} as const;
```

### 3.3 动画时长常量

```typescript
export const ANIMATION_DURATION = {
  SHORT: 200,
  MEDIUM: 300,
  LONG: 500,
} as const;
```

### 3.4 业务配置常量

```typescript
export const BUSINESS_CONFIG = {
  // 业务相关配置...
} as const;
```

### 3.5 API配置常量

```typescript
export const API_CONFIG = {
  BASE_URL: '/api/v1/{module}',
  TIMEOUT: 10000,
  PAGE_SIZE: 20,
} as const;
```

---

## 🌐 四、前端API接口层设计

### 4.1 主页面API（api{ModuleName}Main.[ext]）

```typescript
import { ApiResponse, {Entity}ListResponse } from './types';

/**
 * 获取主页面数据
 */
export async function get{ModuleName}MainData(
  params: PageQuery
): Promise<ApiResponse<{Entity}ListResponse>> {
  // API实现
}

/**
 * 其他主页面API...
 */
```

### 4.2 子功能API（api{ModuleName}{SubFunction}.[ext]）

```typescript
/**
 * 子功能相关API定义
 */
export async function {action}{SubFunction}(
  params: {Action}Request
): Promise<ApiResponse<{Entity}>> {
  // API实现
}
```

### 4.3 聚合API（api{ModuleName}Aggregate.[ext]）

```typescript
/**
 * 聚合多个API调用（仅在前端需要时创建）
 */
export async function get{ModuleName}AggregateData(
  params: any
): Promise<ApiResponse<any>> {
  // 聚合API实现
}
```

---

## 🔌 五、后端交互层设计（MyBatis-Plus标准）

### 5.1 数据实体（entity{ModuleName}.[ext]）

```java
import com.baomidou.mybatisplus.annotation.*;

@TableName("{table_name}")
public class {ModuleName}Entity {
    @TableId(type = IdType.AUTO)
    private Long id;
    
    private String field1;
    private String field2;
    
    @TableField(fill = FieldFill.INSERT)
    private LocalDateTime createdAt;
    
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updatedAt;
    
    // Getters and Setters
}
```

### 5.2 数据传输对象（dto{ModuleName}{Action}.[ext]）

```java
public class {ModuleName}{Action}DTO {
    // DTO字段定义（与前端API一致）
    
    // Validation注解
    // Getters and Setters
}
```

### 5.3 查询视图对象（vo{ModuleName}Query.[ext]）

```java
public class {ModuleName}QueryVO {
    // 查询条件字段
    private Integer page;
    private Integer pageSize;
    // 其他查询条件...
    
    // Getters and Setters
}
```

### 5.4 控制器（controller{ModuleName}.[ext]）

```java
@RestController
@RequestMapping("/api/v1/{module}")
public class {ModuleName}Controller {
    
    @Autowired
    private {ModuleName}Service service;
    
    @GetMapping("/list")
    public ApiResponse<PageResult<{ModuleName}Entity>> getList(
        @RequestBody {ModuleName}QueryVO query
    ) {
        return ApiResponse.success(service.getList(query));
    }
    
    // 其他接口方法...
}
```

### 5.5 服务接口（service{ModuleName}.[ext]）

```java
public interface {ModuleName}Service {
    PageResult<{ModuleName}Entity> getList({ModuleName}QueryVO query);
    {ModuleName}Entity getById(Long id);
    // 其他服务方法...
}
```

### 5.6 服务实现（serviceImpl{ModuleName}.[ext]）

```java
@Service
public class {ModuleName}ServiceImpl implements {ModuleName}Service {
    
    @Autowired
    private {ModuleName}Mapper mapper;
    
    @Override
    public PageResult<{ModuleName}Entity> getList({ModuleName}QueryVO query) {
        // 使用QueryWrapper/LambdaQueryWrapper
        LambdaQueryWrapper<{ModuleName}Entity> wrapper = new LambdaQueryWrapper<>();
        wrapper.eq({ModuleName}Entity::getStatus, 1)
               .orderByDesc({ModuleName}Entity::getCreatedAt);
        
        Page<{ModuleName}Entity> page = new Page<>(query.getPage(), query.getPageSize());
        return mapper.selectPage(page, wrapper);
    }
    
    // 其他服务实现...
}
```

### 5.7 Mapper接口（mapper{ModuleName}.[ext]）

```java
@Mapper
public interface {ModuleName}Mapper extends BaseMapper<{ModuleName}Entity> {
    // 利用MyBatis-Plus内置方法
    // 复杂查询可在此定义（可选）
}
```

### 5.8 查询构建器（query{ModuleName}Builder.[ext]）（可选）

```java
public class {ModuleName}QueryBuilder {
    
    public static LambdaQueryWrapper<{ModuleName}Entity> buildQuery(
        {ModuleName}QueryVO query
    ) {
        LambdaQueryWrapper<{ModuleName}Entity> wrapper = new LambdaQueryWrapper<>();
        
        // 封装复杂查询逻辑
        if (query.getKeyword() != null) {
            wrapper.like({ModuleName}Entity::getTitle, query.getKeyword());
        }
        
        return wrapper;
    }
}
```

---

## 📝 六、八段式代码结构规范

### 6.1 主文件结构模板（index.[ext]）

```typescript
// #region 1. File Banner & TOC
/**
 * {ComponentName} - {功能描述}
 * 
 * TOC (快速跳转):
 * [1] Imports
 * [2] Types & Schema
 * [3] Constants & Config
 * [4] Utils & Helpers
 * [5] State Management
 * [6] Domain Logic
 * [7] UI Components & Rendering
 * [8] Exports
 */
// #endregion

// #region 2. Imports
import React, { useState, useEffect } from 'react';
import { ComponentProps } from './types';
import { CONSTANTS } from './constants';
// #endregion

// #region 3. Types & Schema
interface LocalState {
  // 本地类型定义
}
// #endregion

// #region 4. Constants & Config
const LOCAL_CONSTANTS = {
  // 本地常量
};
// #endregion

// #region 5. Utils & Helpers
// 🎯 集中管理所有工具函数，避免创建独立文件
const formatData = (data: any) => {
  // 工具函数实现
};

const calculateValue = (input: number) => {
  // 计算函数实现
};
// #endregion

// #region 6. State Management
// 🎯 集中管理所有状态，避免创建独立hooks文件
const Component: React.FC<ComponentProps> = (props) => {
  const [state1, setState1] = useState(initialValue);
  const [state2, setState2] = useState(initialValue);
  
  useEffect(() => {
    // 副作用逻辑
  }, [deps]);
  
  // #region 7. Domain Logic
  // 🎯 集中管理所有事件逻辑，避免创建独立文件
  const handleAction = () => {
    // 事件处理逻辑
  };
  
  const processData = async () => {
    // 业务逻辑
  };
  // #endregion
  
  // #region 8. UI Components & Rendering
  return (
    <div>
      {/* JSX内容 */}
    </div>
  );
  // #endregion
};
// #endregion

// #region 9. Exports
export default Component;
// #endregion
```

### 6.2 八段式编写原则

- **🎯 完整单文件**: 每个主文件都应该是完整而自包含的
- **严格分段**: 每段职责单一，使用 `#region` 标记
- **顺序固定**: 必须按1-9的顺序组织代码
- **可折叠导航**: 便于快速定位和代码审查
- **📦 逻辑集中**: 所有状态、事件、数据处理、工具函数都集中在主文件内

---

## 🔄 七、状态管理策略

### 7.1 主文件集中管理（推荐）

```typescript
// ✅ 正确做法：在主文件内直接管理所有状态

// #region 6. State Management
const [activeTab, setActiveTab] = useState<TabType>('default');
const [dataList, setDataList] = useState<DataItem[]>([]);
const [isLoading, setIsLoading] = useState(false);
const [error, setError] = useState<Error | null>(null);

// 数据加载逻辑
useEffect(() => {
  loadData();
}, [activeTab]);

const loadData = async () => {
  setIsLoading(true);
  try {
    const response = await api.getData();
    setDataList(response.data);
  } catch (err) {
    setError(err);
  } finally {
    setIsLoading(false);
  }
};
// #endregion
```

### 7.2 复杂状态适度抽离（仅必要时）

**创建独立Hook的条件：**
- ✅ 状态逻辑超过50行代码
- ✅ 涉及复杂的多步骤流程（>5个步骤）
- ✅ 多个组件需要复用相同逻辑
- ✅ 移动端特有功能（键盘、手势、设备API）

```typescript
// use{ModuleName}Flow.[ext]
export function use{ModuleName}Flow() {
  // 复杂流程状态管理
  const [step, setStep] = useState(1);
  const [flowData, setFlowData] = useState({});
  
  // 复杂流程逻辑...
  
  return {
    step,
    flowData,
    nextStep,
    prevStep,
    completeFlow,
  };
}
```

---

## 🚨 八、错误处理与边界情况

### 8.1 API错误处理

```typescript
const handleApiError = (error: ApiError) => {
  switch (error.code) {
    case 401:
      // 未授权：跳转登录页
      navigateToLogin();
      break;
    case 403:
      // 权限不足
      showToast('权限不足，无法执行该操作');
      break;
    case 404:
      // 资源不存在
      showToast('内容不存在或已被删除');
      break;
    case 429:
      // 请求频繁
      showToast('操作过于频繁，请稍后再试');
      break;
    case 500:
      // 服务器错误
      showToast('服务器异常，请稍后重试');
      break;
    default:
      showToast('操作失败，请重试');
  }
};
```

### 8.2 空状态处理

```typescript
// 空数据状态
const EmptyState = () => (
  <div className="empty-state">
    <img src={emptyIcon} alt="暂无数据" />
    <p>暂无内容</p>
  </div>
);

// 加载状态
const LoadingState = () => (
  <div className="loading-state">
    <Spinner />
    <p>加载中...</p>
  </div>
);

// 错误状态
const ErrorState = ({ error, onRetry }: ErrorStateProps) => (
  <div className="error-state">
    <img src={errorIcon} alt="加载失败" />
    <p>{error.message}</p>
    <button onClick={onRetry}>重试</button>
  </div>
);
```

### 8.3 权限请求处理

```typescript
const requestPermission = async (type: PermissionType) => {
  const result = await requestDevicePermission(type);
  
  if (result === 'denied') {
    showPermissionDialog({
      title: `需要${type}权限`,
      message: `请在设置中开启${type}权限`,
      onConfirm: () => openSettings(),
    });
  }
  
  return result === 'granted';
};
```

---

## ⚡ 九、性能优化实施方案

### 9.1 列表虚拟化

```typescript
import { VirtualList } from '@/components/VirtualList';

<VirtualList
  data={dataList}
  itemHeight={200} // 估算高度
  renderItem={(item) => <ItemCard data={item} />}
  onLoadMore={loadMoreData}
/>
```

### 9.2 图片懒加载

```typescript
<Image
  src={imageUrl}
  lazy={true}
  placeholder={<ImagePlaceholder />}
  onLoad={handleImageLoad}
  onError={handleImageError}
/>
```

### 9.3 数据预加载

```typescript
useEffect(() => {
  // 滚动到底部前预加载下一页
  if (scrollPosition > threshold && hasMore && !isLoading) {
    prefetchNextPage();
  }
}, [scrollPosition]);
```

### 9.4 防抖节流

```typescript
// 搜索输入防抖
const debouncedSearch = useMemo(
  () => debounce((keyword: string) => {
    performSearch(keyword);
  }, 300),
  []
);

// 滚动事件节流
const throttledScroll = useMemo(
  () => throttle((event: ScrollEvent) => {
    handleScroll(event);
  }, 100),
  []
);
```

---

## 📱 十、移动端特性适配

### 10.1 手势交互

```typescript
// 下拉刷新
const handlePullDown = (distance: number) => {
  if (distance > REFRESH_THRESHOLD) {
    triggerRefresh();
  }
};

// 左滑删除
const handleSwipeLeft = (itemId: string) => {
  showDeleteConfirm(itemId);
};
```

### 10.2 设备API使用

```typescript
// 键盘管理
useKeyboardHandler({
  onShow: (height) => adjustInputPosition(height),
  onHide: () => resetInputPosition(),
});

// 安全区域适配
const { top, bottom } = useSafeAreaInsets();

// 网络状态监听
useNetworkStatus({
  onOffline: () => showOfflineToast(),
  onOnline: () => syncOfflineData(),
});
```

---

## 🧪 十一、测试策略

### 11.1 单元测试

```typescript
describe('{ComponentName}', () => {
  it('应该正确渲染', () => {
    // 测试实现
  });
  
  it('应该正确处理用户交互', () => {
    // 测试实现
  });
  
  it('应该正确处理错误状态', () => {
    // 测试实现
  });
});
```

### 11.2 集成测试

```typescript
describe('{ModuleName} Integration', () => {
  it('应该正确完成完整流程', async () => {
    // 集成测试实现
  });
});
```

---

## 📊 十二、监控指标

### 12.1 性能指标
- **首屏加载时间**: < 1s
- **列表滚动帧率**: >= 60fps
- **API响应时间**: < 500ms
- **内存占用**: < 200MB

### 12.2 业务指标
- **日活跃用户**: {目标值}
- **功能使用率**: {目标值}
- **用户满意度**: {目标值}

### 12.3 质量指标
- **崩溃率**: < 0.1%
- **ANR率**: < 0.05%
- **接口成功率**: > 99.9%

---

## 📝 十三、实施检查清单

### ✅ 架构实施完整性检查

- [ ] **文件结构完整性**
  - [ ] 所有核心文件已创建（index/types/constants/README）
  - [ ] MainPage和SubPages结构正确
  - [ ] ComponentAreaName划分合理

- [ ] **前后端一体化完整性**
  - [ ] 前端API接口层文件完整
  - [ ] 后端实现层核心文件完整
  - [ ] 前后端数据类型定义一致
  - [ ] MyBatis-Plus配置正确

- [ ] **代码质量标准**
  - [ ] 所有主文件遵循八段式结构
  - [ ] 状态管理符合主文件优先原则
  - [ ] 类型定义完整无any
  - [ ] 常量全部提取无硬编码

- [ ] **功能完整性**
  - [ ] 核心功能实现完整
  - [ ] 错误处理覆盖全面
  - [ ] 边界情况处理完善
  - [ ] 性能优化已实施

- [ ] **文档完整性**
  - [ ] README文档完整
  - [ ] API文档清晰
  - [ ] 代码注释充分
  - [ ] 使用示例完整

---

## 🚀 十四、实施步骤

### 第一阶段：架构搭建
1. 创建页面组根目录和核心文件
2. 定义完整的类型系统（types.[ext]）
3. 配置所有常量（constants.[ext]）
4. 编写架构文档（README.md）

### 第二阶段：前后端一体化实施
5. 创建前端API接口层文件
6. 创建后端实现层所有文件
7. 配置MyBatis-Plus和QueryWrapper
8. 测试前后端数据交互

### 第三阶段：页面组件实施
9. 实施MainPage及其ComponentAreaName
10. 实施所有SubPages
11. 集成状态管理和导航
12. 实施错误处理和边界情况

### 第四阶段：优化与测试
13. 性能优化实施
14. 单元测试和集成测试
15. 代码审查和重构
16. 文档完善和交付

---

## 📌 十五、注意事项

### 🚨 强制执行项
- ✅ 前后端必须同时完整交付
- ✅ 所有主文件必须遵循八段式结构
- ✅ 状态管理优先在主文件内集中
- ✅ 数据访问层统一使用MyBatis-Plus

### ⚠️ 避免的错误
- ❌ 仅创建前端接口而忽略后端实现
- ❌ 过度创建独立的hooks/utils文件
- ❌ 硬编码常量和魔法数字
- ❌ 过度设计未使用的接口

### 💡 最佳实践
- ✅ 按需设计，YAGNI原则
- ✅ 主文件完整自包含
- ✅ 代码可读性优先
- ✅ 持续重构优化

---

**版本**: v2.0  
**更新日期**: 2024年  
**基于标准**: UNIVERSAL_COMPONENT_ARCHITECTURE_CORE v2.5  
**适用范围**: 所有模块的架构设计和实施
