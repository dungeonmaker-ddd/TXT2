# 💬 消息模块架构设计文档 v2.0

> **基于UNIVERSAL_COMPONENT_ARCHITECTURE_CORE v2.5标准**  
> **完整前后端一体化 + 层级化页面组架构 + 八段式代码规范**

---

## 📋 文档信息

- **模块名称**：Messages（消息模块）
- **页面类型**：消息通信、通知管理、社交互动
- **设计标准**：UNIVERSAL_COMPONENT_ARCHITECTURE_CORE v2.5
- **创建日期**：2024年
- **版本号**：v2.0
- **适用项目**：XiangYuPai探店APP
- **技术栈**：React Native + Expo Router + TypeScript + MyBatis-Plus

---

## 🎯 核心设计原则遵循检查清单

### ✅ 架构标准强制执行项

- [x] **层级化页面组主导架构** - MainPage + SubPages结构
- [x] **前后端一体化强制实施** - API层与后端实现层同时完整交付
- [x] **MyBatis-Plus标准架构** - QueryWrapper/LambdaQueryWrapper查询
- [x] **八段式代码结构** - 所有主文件遵循八段式规范
- [x] **主文件优先原则** - 状态/事件/数据处理集中在主文件内
- [x] **按需设计原则** - 仅创建前端实际需要的接口
- [x] **类型安全** - 完整的TypeScript类型定义
- [x] **常量规范** - 所有常量在constants.[ext]中定义

---

## 📦 一、模块架构总览

### 1.1 页面组层级结构

```
src/pages/Messages/                        # 📦 消息模块页面组
├── index.tsx                               # 🎯 页面组主文件 - 状态管理、导航协调
├── types.ts                                # 📋 页面组类型定义
├── constants.ts                            # ⚙️ 页面组常量配置
├── README.md                               # 📖 页面组文档
│
├── 🏠 主页面层 (Main Page)
│   ├── MainPage/                           # 📱 消息主页面
│   │   ├── index.tsx                       # 主页面实现（八段式结构）
│   │   ├── types.ts                        # 主页面类型定义
│   │   ├── constants.ts                    # 主页面常量配置
│   │   ├── README.md                       # 主页面文档
│   │   │
│   │   ├── NavigationArea/                 # ✅ 导航栏区域组件
│   │   │   ├── index.tsx                   # 🎯 区域组件主文件（八段式）
│   │   │   └── README.md                   # 区域文档
│   │   │
│   │   ├── CategoryArea/                   # ✅ 4宫格分类区域组件
│   │   │   ├── index.tsx                   # 🎯 区域组件主文件（八段式）
│   │   │   ├── types.ts                    # 区域类型定义
│   │   │   ├── constants.ts                # 区域常量配置
│   │   │   └── README.md                   # 区域文档
│   │   │
│   │   └── ConversationArea/               # ✅ 对话列表区域组件
│   │       ├── index.tsx                   # 🎯 区域组件主文件（八段式）
│   │       ├── types.ts                    # 区域类型定义
│   │       ├── constants.ts                # 区域常量配置
│   │       └── README.md                   # 区域文档
│   │
├── 📄 子页面层 (Sub Pages)
│   ├── LikesPage/                          # 赞和收藏消息页面
│   │   ├── index.tsx                       # 页面实现（八段式）
│   │   ├── types.ts                        # 页面类型定义
│   │   ├── constants.ts                    # 页面常量配置
│   │   └── README.md                       # 页面文档
│   │
│   ├── CommentsPage/                       # 评论消息页面
│   │   ├── index.tsx                       # 页面实现（八段式）
│   │   ├── types.ts                        # 页面类型定义
│   │   ├── constants.ts                    # 页面常量配置
│   │   └── README.md                       # 页面文档
│   │
│   ├── FollowersPage/                      # 粉丝消息页面
│   │   ├── index.tsx                       # 页面实现（八段式）
│   │   ├── types.ts                        # 页面类型定义
│   │   ├── constants.ts                    # 页面常量配置
│   │   └── README.md                       # 页面文档
│   │
│   ├── NotificationsPage/                  # 系统通知页面
│   │   ├── index.tsx                       # 页面实现（八段式）
│   │   ├── types.ts                        # 页面类型定义
│   │   ├── constants.ts                    # 页面常量配置
│   │   └── README.md                       # 页面文档
│   │
│   └── ChatPage/                           # 私聊对话页面
│       ├── index.tsx                       # 页面实现（八段式）
│       ├── types.ts                        # 页面类型定义
│       ├── constants.ts                    # 页面常量配置
│       └── README.md                       # 页面文档
│
├── 🌐 API接口层（前端）
│   ├── apiMessagesMain.ts                  # 消息主页面API
│   ├── apiMessagesLikes.ts                 # 赞和收藏API
│   ├── apiMessagesComments.ts              # 评论API
│   ├── apiMessagesFollowers.ts             # 粉丝API
│   ├── apiMessagesNotifications.ts         # 系统通知API
│   ├── apiMessagesChat.ts                  # 私聊对话API
│   └── apiMessagesAggregate.ts             # 聚合API（可选）
│
└── 🔌 后端交互层（Java/Kotlin + MyBatis-Plus）
    └── backend/
        ├── entityMessage.java              # 🏗️ 消息实体（MyBatis-Plus）
        ├── entityConversation.java         # 🏗️ 对话实体
        ├── entityNotification.java         # 🏗️ 通知实体
        ├── dtoMessageCreate.java           # 📦 创建消息DTO
        ├── dtoMessageUpdate.java           # 📦 更新消息DTO
        ├── voMessageQuery.java             # 🔍 消息查询VO
        ├── controllerMessages.java         # 🎯 消息控制器
        ├── serviceMessages.java            # ⚙️ 消息服务接口
        ├── serviceImplMessages.java        # 🔧 消息服务实现（QueryWrapper）
        ├── mapperMessages.java             # 🗄️ 消息Mapper接口
        └── queryMessagesBuilder.java       # 🏗️ 查询构建器（可选）
```

### 1.2 页面层级说明

| 层级 | 命名规范 | 职责 | 示例 |
|------|---------|------|------|
| **页面组** | `Messages/` | 完整业务模块 | 消息通信模块 |
| **主页面** | `MainPage/` | 模块主入口 | 消息主页面 |
| **子页面** | `{SubFunction}Page/` | 子功能页面 | `LikesPage/`, `ChatPage/` |
| **区域组件** | `{ComponentAreaName}/` | 页面功能区域 | `CategoryArea/`, `ConversationArea/` |

---

## 📋 二、核心类型定义（types.ts）

### 2.1 页面组级别类型

```typescript
// 页面组Props接口
export interface MessagesProps {
  initialTab?: MessageTab;
  userId?: string;
}

// 页面组状态类型
export interface MessagesState {
  activeTab: MessageTab;
  unreadCounts: UnreadCounts;
  isLoading: boolean;
}

// Tab类型
export type MessageTab = 'main' | 'likes' | 'comments' | 'followers' | 'notifications' | 'chat';

// 未读数量统计
export interface UnreadCounts {
  likes: number;
  comments: number;
  followers: number;
  notifications: number;
  conversations: number;
  total: number;
}
```

### 2.2 数据实体类型

```typescript
// 消息实体类型
export interface Message {
  id: string;
  type: MessageType;
  senderId: string;
  receiverId: string;
  content: string;
  contentType: ContentType;
  status: MessageStatus;
  isRead: boolean;
  createdAt: number;
  updatedAt: number;
}

// 对话实体类型
export interface Conversation {
  id: string;
  userId: string;
  userAvatar: string;
  userName: string;
  lastMessage: string;
  lastMessageTime: number;
  unreadCount: number;
  isRead: boolean;
  isOnline: boolean;
}

// 通知实体类型
export interface Notification {
  id: string;
  type: NotificationType;
  title: string;
  content: string;
  priority: NotificationPriority;
  actionUrl?: string;
  actionLabel?: string;
  isRead: boolean;
  createdAt: number;
}

// 点赞收藏消息类型
export interface LikeMessage {
  id: string;
  userId: string;
  userAvatar: string;
  userName: string;
  actionType: 'like' | 'collect';
  targetType: 'post' | 'comment';
  targetId: string;
  targetContent: string;
  targetThumbnail?: string;
  createdAt: number;
}

// 评论消息类型
export interface CommentMessage {
  id: string;
  userId: string;
  userAvatar: string;
  userName: string;
  commentContent: string;
  targetType: 'post' | 'comment';
  targetId: string;
  targetContent: string;
  targetThumbnail?: string;
  createdAt: number;
}

// 粉丝消息类型
export interface FollowerMessage {
  id: string;
  userId: string;
  userAvatar: string;
  userName: string;
  userBio?: string;
  followStatus: FollowStatus;
  createdAt: number;
}
```

### 2.3 枚举类型

```typescript
// 消息类型
export enum MessageType {
  TEXT = 'text',
  IMAGE = 'image',
  VOICE = 'voice',
  VIDEO = 'video',
}

// 内容类型
export enum ContentType {
  TEXT = 'text',
  IMAGE = 'image',
  VOICE = 'voice',
  VIDEO = 'video',
}

// 消息状态
export enum MessageStatus {
  SENDING = 'sending',
  SENT = 'sent',
  DELIVERED = 'delivered',
  READ = 'read',
  FAILED = 'failed',
}

// 通知类型
export enum NotificationType {
  SYSTEM = 'system',
  ACTIVITY = 'activity',
  UPDATE = 'update',
}

// 通知优先级
export enum NotificationPriority {
  HIGH = 'high',
  NORMAL = 'normal',
  LOW = 'low',
}

// 关注状态
export enum FollowStatus {
  NOT_FOLLOWING = 'not_following',
  FOLLOWING = 'following',
  MUTUAL = 'mutual',
}
```

### 2.4 API交互类型

```typescript
// API响应类型
export interface ApiResponse<T> {
  code: number;
  message: string;
  data: T;
}

// 分页查询参数
export interface PageQuery {
  page: number;
  pageSize: number;
}

// 分页响应类型
export interface PageResponse<T> {
  list: T[];
  total: number;
  page: number;
  pageSize: number;
  hasMore: boolean;
}

// 消息列表响应
export type MessageListResponse = PageResponse<Message>;
export type ConversationListResponse = PageResponse<Conversation>;
export type NotificationListResponse = PageResponse<Notification>;
export type LikeMessageListResponse = PageResponse<LikeMessage>;
export type CommentMessageListResponse = PageResponse<CommentMessage>;
export type FollowerMessageListResponse = PageResponse<FollowerMessage>;
```

### 2.5 组件Props类型

```typescript
// CategoryArea Props
export interface CategoryAreaProps {
  unreadCounts: UnreadCounts;
  onCategoryPress: (category: string) => void;
  style?: StyleProp<ViewStyle>;
}

// ConversationArea Props
export interface ConversationAreaProps {
  conversations: Conversation[];
  onConversationPress: (id: string) => void;
  onConversationDelete: (id: string) => void;
  onRefresh: () => void;
  refreshing: boolean;
  style?: StyleProp<ViewStyle>;
}

// MessageItem Props
export interface MessageItemProps {
  id: string;
  type: 'conversation' | 'like' | 'comment' | 'follower' | 'notification';
  avatar: string;
  title: string;
  subtitle: string;
  thumbnail?: string;
  timestamp: number;
  isRead: boolean;
  unreadCount?: number;
  actionButton?: {
    label: string;
    onPress: () => void;
  };
  onPress: () => void;
  onLongPress?: () => void;
  onDelete?: () => void;
  style?: StyleProp<ViewStyle>;
}
```

---

## ⚙️ 三、常量配置（constants.ts）

### 3.1 UI尺寸常量

```typescript
export const UI_SIZES = {
  SYSTEM_STATUS_BAR_HEIGHT: 44,
  NAVIGATION_BAR_HEIGHT: 56,
  BOTTOM_TAB_BAR_HEIGHT: 80,
  SAFE_AREA_BOTTOM: 34,
  
  // 分类卡片
  CATEGORY_CARD_SIZE: 80,
  CATEGORY_CARD_SPACING: 16,
  CATEGORY_ICON_SIZE: 32,
  
  // 头像尺寸
  USER_AVATAR_SIZE: 48,
  USER_AVATAR_SIZE_SMALL: 36,
  USER_AVATAR_SIZE_LARGE: 64,
  
  // 消息项
  MESSAGE_ITEM_HEIGHT: 80,
  MESSAGE_THUMBNAIL_SIZE: 48,
  
  // 卡片边距
  CARD_PADDING_HORIZONTAL: 16,
  CARD_PADDING_VERTICAL: 12,
  
  // 圆角
  BORDER_RADIUS_SMALL: 6,
  BORDER_RADIUS_MEDIUM: 8,
  BORDER_RADIUS_LARGE: 12,
  BORDER_RADIUS_XLARGE: 16,
  
  // 角标
  BADGE_SIZE: 14,
  BADGE_LARGE_SIZE: 16,
} as const;
```

### 3.2 颜色常量

```typescript
export const COLORS = {
  // 主色调
  PRIMARY: '#8A2BE2',
  PRIMARY_LIGHT: '#9D4EDD',
  PRIMARY_DARK: '#7209B7',
  
  // 文字颜色
  TEXT_PRIMARY: '#000000',
  TEXT_SECONDARY: '#666666',
  TEXT_TERTIARY: '#999999',
  TEXT_PLACEHOLDER: '#CCCCCC',
  TEXT_WHITE: '#FFFFFF',
  
  // 背景颜色
  BACKGROUND_WHITE: '#FFFFFF',
  BACKGROUND_GRAY: '#F5F5F5',
  BACKGROUND_DARK: '#F0F0F0',
  
  // 分隔线
  BORDER_LIGHT: '#E5E5E5',
  BORDER_MEDIUM: '#DDDDDD',
  BORDER_DARK: '#CCCCCC',
  
  // 功能色
  SUCCESS: '#34C759',
  WARNING: '#FF9500',
  ERROR: '#FF3B30',
  INFO: '#007AFF',
  
  // 分类卡片颜色
  CATEGORY_LIKES: '#FF69B4',
  CATEGORY_COMMENTS: '#4A90E2',
  CATEGORY_FOLLOWERS: '#FF8C00',
  CATEGORY_NOTIFICATIONS: '#5856D6',
  
  // 状态色
  ONLINE: '#34C759',
  OFFLINE: '#999999',
  UNREAD: '#FF3B30',
  READ: '#999999',
} as const;
```

### 3.3 动画时长常量

```typescript
export const ANIMATION_DURATION = {
  SHORT: 200,
  MEDIUM: 300,
  LONG: 500,
  EXTRA_LONG: 800,
} as const;
```

### 3.4 业务配置常量

```typescript
export const MESSAGES_CONFIG = {
  // 分页配置
  PAGE_SIZE: 20,
  
  // 时间格式
  TIME_FORMAT: {
    JUST_NOW: '刚刚',
    MINUTES_AGO: (m: number) => `${m}分钟前`,
    HOURS_AGO: (h: number) => `${h}小时前`,
    YESTERDAY: '昨天',
    DATE_FORMAT: 'MM-DD',
  },
  
  // 未读数量显示
  UNREAD_COUNT_MAX: 99,
  UNREAD_COUNT_OVERFLOW: '99+',
  
  // 消息内容预览长度
  MESSAGE_PREVIEW_LENGTH: 50,
  
  // 刷新配置
  PULL_REFRESH_THRESHOLD: 80,
  AUTO_REFRESH_INTERVAL: 60000, // 60秒
  
  // WebSocket配置
  WS_RECONNECT_INTERVAL: 3000,
  WS_MAX_RECONNECT_ATTEMPTS: 5,
} as const;

// 分类配置
export const CATEGORIES = [
  {
    id: 'likes',
    title: '赞和收藏',
    icon: 'heart',
    color: COLORS.CATEGORY_LIKES,
    route: '/messages/likes',
  },
  {
    id: 'comments',
    title: '评论',
    icon: 'message',
    color: COLORS.CATEGORY_COMMENTS,
    route: '/messages/comments',
  },
  {
    id: 'followers',
    title: '粉丝',
    icon: 'users',
    color: COLORS.CATEGORY_FOLLOWERS,
    route: '/messages/followers',
  },
  {
    id: 'notifications',
    title: '系统通知',
    icon: 'bell',
    color: COLORS.CATEGORY_NOTIFICATIONS,
    route: '/messages/notifications',
  },
] as const;
```

### 3.5 API配置常量

```typescript
export const API_CONFIG = {
  BASE_URL: '/api/v1/messages',
  TIMEOUT: 10000,
  PAGE_SIZE: 20,
  
  ENDPOINTS: {
    // 主页面
    CONVERSATIONS_LIST: '/conversations',
    UNREAD_COUNTS: '/unread/counts',
    
    // 子功能
    LIKES_LIST: '/likes',
    COMMENTS_LIST: '/comments',
    FOLLOWERS_LIST: '/followers',
    NOTIFICATIONS_LIST: '/notifications',
    
    // 对话
    CHAT_MESSAGES: '/chat/:conversationId/messages',
    SEND_MESSAGE: '/chat/:conversationId/send',
    
    // 操作
    MARK_READ: '/:id/read',
    DELETE_MESSAGE: '/:id',
    CLEAR_ALL: '/:type/clear',
  },
} as const;
```

---

## 🌐 四、前端API接口层设计

### 4.1 主页面API（apiMessagesMain.ts）

```typescript
import { ApiResponse, PageQuery, ConversationListResponse, UnreadCounts } from './types';
import { API_CONFIG } from './constants';

/**
 * 获取对话列表
 */
export async function getConversationList(
  params: PageQuery
): Promise<ApiResponse<ConversationListResponse>> {
  const response = await fetch(
    `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.CONVERSATIONS_LIST}?page=${params.page}&pageSize=${params.pageSize}`,
    {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
      },
    }
  );
  
  return response.json();
}

/**
 * 获取未读消息数量统计
 */
export async function getUnreadCounts(): Promise<ApiResponse<UnreadCounts>> {
  const response = await fetch(
    `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.UNREAD_COUNTS}`,
    {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
      },
    }
  );
  
  return response.json();
}

/**
 * 标记对话为已读
 */
export async function markConversationRead(
  conversationId: string
): Promise<ApiResponse<void>> {
  const response = await fetch(
    `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.MARK_READ.replace(':id', conversationId)}`,
    {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
      },
    }
  );
  
  return response.json();
}

/**
 * 删除对话
 */
export async function deleteConversation(
  conversationId: string
): Promise<ApiResponse<void>> {
  const response = await fetch(
    `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.DELETE_MESSAGE.replace(':id', conversationId)}`,
    {
      method: 'DELETE',
      headers: {
        'Content-Type': 'application/json',
      },
    }
  );
  
  return response.json();
}
```

### 4.2 赞和收藏API（apiMessagesLikes.ts）

```typescript
import { ApiResponse, PageQuery, LikeMessageListResponse } from './types';
import { API_CONFIG } from './constants';

/**
 * 获取赞和收藏消息列表
 */
export async function getLikeMessageList(
  params: PageQuery
): Promise<ApiResponse<LikeMessageListResponse>> {
  const response = await fetch(
    `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.LIKES_LIST}?page=${params.page}&pageSize=${params.pageSize}`,
    {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
      },
    }
  );
  
  return response.json();
}

/**
 * 清空所有赞和收藏消息
 */
export async function clearAllLikeMessages(): Promise<ApiResponse<void>> {
  const response = await fetch(
    `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.CLEAR_ALL.replace(':type', 'likes')}`,
    {
      method: 'DELETE',
      headers: {
        'Content-Type': 'application/json',
      },
    }
  );
  
  return response.json();
}
```

### 4.3 私聊对话API（apiMessagesChat.ts）

```typescript
import { ApiResponse, PageQuery, Message, MessageListResponse } from './types';
import { API_CONFIG } from './constants';

/**
 * 获取对话消息列表
 */
export async function getChatMessages(
  conversationId: string,
  params: PageQuery
): Promise<ApiResponse<MessageListResponse>> {
  const url = API_CONFIG.ENDPOINTS.CHAT_MESSAGES.replace(':conversationId', conversationId);
  const response = await fetch(
    `${API_CONFIG.BASE_URL}${url}?page=${params.page}&pageSize=${params.pageSize}`,
    {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
      },
    }
  );
  
  return response.json();
}

/**
 * 发送消息
 */
export async function sendMessage(
  conversationId: string,
  content: string,
  contentType: string
): Promise<ApiResponse<Message>> {
  const url = API_CONFIG.ENDPOINTS.SEND_MESSAGE.replace(':conversationId', conversationId);
  const response = await fetch(
    `${API_CONFIG.BASE_URL}${url}`,
    {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        content,
        contentType,
      }),
    }
  );
  
  return response.json();
}
```

---

## 🔌 五、后端交互层设计（MyBatis-Plus标准）

### 5.1 数据实体（entityMessage.java）

```java
import com.baomidou.mybatisplus.annotation.*;
import lombok.Data;
import java.time.LocalDateTime;

@Data
@TableName("messages")
public class MessageEntity {
    @TableId(type = IdType.AUTO)
    private Long id;
    
    private String type;
    private Long senderId;
    private Long receiverId;
    private String content;
    private String contentType;
    private String status;
    private Boolean isRead;
    
    @TableField(fill = FieldFill.INSERT)
    private LocalDateTime createdAt;
    
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updatedAt;
}

@Data
@TableName("conversations")
public class ConversationEntity {
    @TableId(type = IdType.AUTO)
    private Long id;
    
    private Long userId;
    private String lastMessage;
    private LocalDateTime lastMessageTime;
    private Integer unreadCount;
    private Boolean isRead;
    
    @TableField(fill = FieldFill.INSERT)
    private LocalDateTime createdAt;
    
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updatedAt;
}

@Data
@TableName("notifications")
public class NotificationEntity {
    @TableId(type = IdType.AUTO)
    private Long id;
    
    private String type;
    private String title;
    private String content;
    private String priority;
    private String actionUrl;
    private String actionLabel;
    private Boolean isRead;
    
    @TableField(fill = FieldFill.INSERT)
    private LocalDateTime createdAt;
    
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updatedAt;
}
```

### 5.2 数据传输对象（dtoMessageCreate.java）

```java
import lombok.Data;
import javax.validation.constraints.*;

@Data
public class MessageCreateDTO {
    @NotNull(message = "接收者ID不能为空")
    private Long receiverId;
    
    @NotBlank(message = "消息内容不能为空")
    @Size(max = 1000, message = "消息内容不能超过1000字符")
    private String content;
    
    @NotBlank(message = "内容类型不能为空")
    private String contentType;
}

@Data
public class MessageUpdateDTO {
    @NotNull(message = "消息ID不能为空")
    private Long id;
    
    private Boolean isRead;
    private String status;
}
```

### 5.3 查询视图对象（voMessageQuery.java）

```java
import lombok.Data;

@Data
public class MessageQueryVO {
    private Integer page = 1;
    private Integer pageSize = 20;
    
    // 查询条件
    private Long userId;
    private String type;
    private Boolean isRead;
    private Long startTime;
    private Long endTime;
    
    // 排序
    private String sortBy = "created_at";
    private String sortOrder = "DESC";
}
```

### 5.4 控制器（controllerMessages.java）

```java
import org.springframework.web.bind.annotation.*;
import org.springframework.beans.factory.annotation.Autowired;
import javax.validation.Valid;

@RestController
@RequestMapping("/api/v1/messages")
public class MessagesController {
    
    @Autowired
    private MessagesService messagesService;
    
    /**
     * 获取对话列表
     */
    @GetMapping("/conversations")
    public ApiResponse<PageResult<ConversationEntity>> getConversationList(
        @RequestParam Integer page,
        @RequestParam Integer pageSize
    ) {
        PageResult<ConversationEntity> result = messagesService.getConversationList(page, pageSize);
        return ApiResponse.success(result);
    }
    
    /**
     * 获取未读消息数量统计
     */
    @GetMapping("/unread/counts")
    public ApiResponse<UnreadCounts> getUnreadCounts() {
        UnreadCounts counts = messagesService.getUnreadCounts();
        return ApiResponse.success(counts);
    }
    
    /**
     * 获取对话消息列表
     */
    @GetMapping("/chat/{conversationId}/messages")
    public ApiResponse<PageResult<MessageEntity>> getChatMessages(
        @PathVariable Long conversationId,
        @RequestParam Integer page,
        @RequestParam Integer pageSize
    ) {
        PageResult<MessageEntity> result = messagesService.getChatMessages(conversationId, page, pageSize);
        return ApiResponse.success(result);
    }
    
    /**
     * 发送消息
     */
    @PostMapping("/chat/{conversationId}/send")
    public ApiResponse<MessageEntity> sendMessage(
        @PathVariable Long conversationId,
        @Valid @RequestBody MessageCreateDTO dto
    ) {
        MessageEntity message = messagesService.sendMessage(conversationId, dto);
        return ApiResponse.success(message);
    }
    
    /**
     * 标记消息为已读
     */
    @PutMapping("/{id}/read")
    public ApiResponse<Void> markRead(@PathVariable Long id) {
        messagesService.markRead(id);
        return ApiResponse.success();
    }
    
    /**
     * 删除消息
     */
    @DeleteMapping("/{id}")
    public ApiResponse<Void> deleteMessage(@PathVariable Long id) {
        messagesService.deleteMessage(id);
        return ApiResponse.success();
    }
    
    /**
     * 清空某类消息
     */
    @DeleteMapping("/{type}/clear")
    public ApiResponse<Void> clearAll(@PathVariable String type) {
        messagesService.clearAll(type);
        return ApiResponse.success();
    }
}
```

### 5.5 服务接口（serviceMessages.java）

```java
public interface MessagesService {
    PageResult<ConversationEntity> getConversationList(Integer page, Integer pageSize);
    UnreadCounts getUnreadCounts();
    PageResult<MessageEntity> getChatMessages(Long conversationId, Integer page, Integer pageSize);
    MessageEntity sendMessage(Long conversationId, MessageCreateDTO dto);
    void markRead(Long id);
    void deleteMessage(Long id);
    void clearAll(String type);
}
```

### 5.6 服务实现（serviceImplMessages.java）

```java
import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import org.springframework.stereotype.Service;
import org.springframework.beans.factory.annotation.Autowired;

@Service
public class MessagesServiceImpl implements MessagesService {
    
    @Autowired
    private MessagesMapper messagesMapper;
    
    @Autowired
    private ConversationsMapper conversationsMapper;
    
    @Override
    public PageResult<ConversationEntity> getConversationList(Integer page, Integer pageSize) {
        // 使用LambdaQueryWrapper查询
        LambdaQueryWrapper<ConversationEntity> wrapper = new LambdaQueryWrapper<>();
        wrapper.orderByDesc(ConversationEntity::getLastMessageTime);
        
        Page<ConversationEntity> pageObj = new Page<>(page, pageSize);
        Page<ConversationEntity> result = conversationsMapper.selectPage(pageObj, wrapper);
        
        return PageResult.of(result);
    }
    
    @Override
    public UnreadCounts getUnreadCounts() {
        UnreadCounts counts = new UnreadCounts();
        
        // 使用QueryWrapper统计未读消息
        LambdaQueryWrapper<ConversationEntity> wrapper = new LambdaQueryWrapper<>();
        wrapper.eq(ConversationEntity::getIsRead, false);
        
        Long unreadConversations = conversationsMapper.selectCount(wrapper);
        counts.setConversations(unreadConversations.intValue());
        
        // 统计其他类型未读消息...
        
        return counts;
    }
    
    @Override
    public PageResult<MessageEntity> getChatMessages(Long conversationId, Integer page, Integer pageSize) {
        LambdaQueryWrapper<MessageEntity> wrapper = new LambdaQueryWrapper<>();
        wrapper.eq(MessageEntity::getReceiverId, conversationId)
               .or()
               .eq(MessageEntity::getSenderId, conversationId)
               .orderByDesc(MessageEntity::getCreatedAt);
        
        Page<MessageEntity> pageObj = new Page<>(page, pageSize);
        Page<MessageEntity> result = messagesMapper.selectPage(pageObj, wrapper);
        
        return PageResult.of(result);
    }
    
    @Override
    public MessageEntity sendMessage(Long conversationId, MessageCreateDTO dto) {
        MessageEntity message = new MessageEntity();
        message.setReceiverId(dto.getReceiverId());
        message.setContent(dto.getContent());
        message.setContentType(dto.getContentType());
        message.setStatus("sent");
        message.setIsRead(false);
        
        messagesMapper.insert(message);
        
        // 更新对话最后消息
        updateConversationLastMessage(conversationId, message);
        
        return message;
    }
    
    @Override
    public void markRead(Long id) {
        LambdaQueryWrapper<MessageEntity> wrapper = new LambdaQueryWrapper<>();
        wrapper.eq(MessageEntity::getId, id);
        
        MessageEntity message = new MessageEntity();
        message.setIsRead(true);
        
        messagesMapper.update(message, wrapper);
    }
    
    @Override
    public void deleteMessage(Long id) {
        messagesMapper.deleteById(id);
    }
    
    @Override
    public void clearAll(String type) {
        LambdaQueryWrapper<MessageEntity> wrapper = new LambdaQueryWrapper<>();
        wrapper.eq(MessageEntity::getType, type);
        
        messagesMapper.delete(wrapper);
    }
    
    private void updateConversationLastMessage(Long conversationId, MessageEntity message) {
        // 更新对话最后消息逻辑
    }
}
```

### 5.7 Mapper接口（mapperMessages.java）

```java
import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import org.apache.ibatis.annotations.Mapper;

@Mapper
public interface MessagesMapper extends BaseMapper<MessageEntity> {
    // 继承BaseMapper，利用MyBatis-Plus内置方法
}

@Mapper
public interface ConversationsMapper extends BaseMapper<ConversationEntity> {
    // 继承BaseMapper，利用MyBatis-Plus内置方法
}

@Mapper
public interface NotificationsMapper extends BaseMapper<NotificationEntity> {
    // 继承BaseMapper，利用MyBatis-Plus内置方法
}
```

---

## 📝 六、八段式代码结构规范

### 6.1 MainPage主文件结构（index.tsx）

```typescript
// #region 1. File Banner & TOC
/**
 * MainPage - 消息模块主页面
 * 
 * 功能描述：消息主页面，包含4宫格分类、对话列表、导航栏
 * 
 * TOC (快速跳转):
 * [1] Imports
 * [2] Types & Schema
 * [3] Constants & Config
 * [4] Utils & Helpers
 * [5] State Management
 * [6] Domain Logic
 * [7] UI Components & Rendering
 * [8] Exports
 */
// #endregion

// #region 2. Imports
import React, { useState, useEffect, useCallback, useMemo } from 'react';
import { View, ScrollView, RefreshControl, StyleSheet } from 'react-native';
import { useRouter } from 'expo-router';

// 内部组件导入
import { NavigationArea } from './NavigationArea';
import { CategoryArea } from './CategoryArea';
import { ConversationArea } from './ConversationArea';

// API和Store导入
import { getConversationList, getUnreadCounts } from '../../api/apiMessagesMain';

// 类型和常量导入
import type { MainPageProps, Conversation, UnreadCounts } from './types';
import { MESSAGES_CONFIG, ANIMATION_DURATION } from './constants';
// #endregion

// #region 3. Types & Schema
// 本地状态类型
interface MainPageState {
  conversations: Conversation[];
  unreadCounts: UnreadCounts;
  isLoading: boolean;
  isRefreshing: boolean;
  error: Error | null;
}
// #endregion

// #region 4. Constants & Config
// 本地常量
const REFRESH_THRESHOLD = 80;
const LOAD_MORE_THRESHOLD = 0.8;
// #endregion

// #region 5. Utils & Helpers
// 🎯 本地工具函数（集中管理，避免创建独立文件）

/**
 * 格式化时间显示
 */
const formatTime = (timestamp: number): string => {
  const now = Date.now();
  const diff = now - timestamp;
  const minutes = Math.floor(diff / 60000);
  const hours = Math.floor(diff / 3600000);
  const days = Math.floor(diff / 86400000);
  
  if (minutes < 1) return MESSAGES_CONFIG.TIME_FORMAT.JUST_NOW;
  if (minutes < 60) return MESSAGES_CONFIG.TIME_FORMAT.MINUTES_AGO(minutes);
  if (hours < 24) return MESSAGES_CONFIG.TIME_FORMAT.HOURS_AGO(hours);
  if (days === 1) return MESSAGES_CONFIG.TIME_FORMAT.YESTERDAY;
  
  const date = new Date(timestamp);
  return `${date.getMonth() + 1}-${date.getDate()}`;
};

/**
 * 格式化未读数量显示
 */
const formatUnreadCount = (count: number): string => {
  if (count === 0) return '';
  if (count > MESSAGES_CONFIG.UNREAD_COUNT_MAX) {
    return MESSAGES_CONFIG.UNREAD_COUNT_OVERFLOW;
  }
  return count.toString();
};

/**
 * 截断消息预览
 */
const truncateMessage = (message: string, maxLength: number = MESSAGES_CONFIG.MESSAGE_PREVIEW_LENGTH): string => {
  if (message.length <= maxLength) return message;
  return message.substring(0, maxLength) + '...';
};
// #endregion

// #region 6. State Management
// 🎯 状态管理Hook（集中管理，避免创建独立hooks文件）

/**
 * 主页面状态管理Hook
 */
const useMainPageState = () => {
  const [conversations, setConversations] = useState<Conversation[]>([]);
  const [unreadCounts, setUnreadCounts] = useState<UnreadCounts>({
    likes: 0,
    comments: 0,
    followers: 0,
    notifications: 0,
    conversations: 0,
    total: 0,
  });
  const [isLoading, setIsLoading] = useState(false);
  const [isRefreshing, setIsRefreshing] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  const [page, setPage] = useState(1);
  const [hasMore, setHasMore] = useState(true);
  
  // 计算总未读数
  const totalUnread = useMemo(() => {
    return unreadCounts.total;
  }, [unreadCounts]);
  
  return {
    conversations,
    setConversations,
    unreadCounts,
    setUnreadCounts,
    isLoading,
    setIsLoading,
    isRefreshing,
    setIsRefreshing,
    error,
    setError,
    page,
    setPage,
    hasMore,
    setHasMore,
    totalUnread,
  };
};

/**
 * 数据加载Hook
 */
const useDataLoading = (state: ReturnType<typeof useMainPageState>) => {
  // 加载对话列表
  const loadConversations = useCallback(async (isRefresh = false) => {
    if (state.isLoading) return;
    
    try {
      if (isRefresh) {
        state.setIsRefreshing(true);
        state.setPage(1);
      } else {
        state.setIsLoading(true);
      }
      
      const currentPage = isRefresh ? 1 : state.page;
      const response = await getConversationList({
        page: currentPage,
        pageSize: MESSAGES_CONFIG.PAGE_SIZE,
      });
      
      if (response.code === 200) {
        const newData = response.data.list;
        if (isRefresh) {
          state.setConversations(newData);
        } else {
          state.setConversations([...state.conversations, ...newData]);
        }
        
        state.setHasMore(response.data.hasMore);
        state.setPage(currentPage + 1);
      }
    } catch (err) {
      state.setError(err as Error);
      console.error('加载对话列表失败:', err);
    } finally {
      state.setIsLoading(false);
      state.setIsRefreshing(false);
    }
  }, [state]);
  
  // 加载未读数量
  const loadUnreadCounts = useCallback(async () => {
    try {
      const response = await getUnreadCounts();
      if (response.code === 200) {
        state.setUnreadCounts(response.data);
      }
    } catch (err) {
      console.error('加载未读数量失败:', err);
    }
  }, [state]);
  
  // 初始化数据
  useEffect(() => {
    loadConversations(true);
    loadUnreadCounts();
  }, []);
  
  // 自动刷新未读数量
  useEffect(() => {
    const interval = setInterval(() => {
      loadUnreadCounts();
    }, MESSAGES_CONFIG.AUTO_REFRESH_INTERVAL);
    
    return () => clearInterval(interval);
  }, [loadUnreadCounts]);
  
  return {
    loadConversations,
    loadUnreadCounts,
  };
};
// #endregion

// #region 7. Domain Logic
// 🎯 事件处理函数（集中管理，避免创建独立文件）

/**
 * 业务逻辑Hook
 */
const useMainPageLogic = (
  state: ReturnType<typeof useMainPageState>,
  loader: ReturnType<typeof useDataLoading>
) => {
  const router = useRouter();
  
  // 分类点击处理
  const handleCategoryPress = useCallback((category: string) => {
    router.push(`/messages/${category}`);
  }, [router]);
  
  // 对话点击处理
  const handleConversationPress = useCallback((conversationId: string) => {
    router.push(`/messages/chat/${conversationId}`);
  }, [router]);
  
  // 对话删除处理
  const handleConversationDelete = useCallback((conversationId: string) => {
    // 显示确认对话框
    // 调用删除API
    // 更新列表
  }, []);
  
  // 下拉刷新处理
  const handleRefresh = useCallback(() => {
    loader.loadConversations(true);
    loader.loadUnreadCounts();
  }, [loader]);
  
  // 加载更多处理
  const handleLoadMore = useCallback(() => {
    if (!state.isLoading && state.hasMore) {
      loader.loadConversations(false);
    }
  }, [state.isLoading, state.hasMore, loader]);
  
  return {
    handleCategoryPress,
    handleConversationPress,
    handleConversationDelete,
    handleRefresh,
    handleLoadMore,
  };
};
// #endregion

// #region 8. UI Components & Rendering
/**
 * 主页面组件
 */
const MainPage: React.FC<MainPageProps> = (props) => {
  const state = useMainPageState();
  const loader = useDataLoading(state);
  const logic = useMainPageLogic(state, loader);
  
  return (
    <View style={styles.container}>
      {/* 导航栏 */}
      <NavigationArea />
      
      {/* 主内容区 */}
      <ScrollView
        style={styles.scrollView}
        refreshControl={
          <RefreshControl
            refreshing={state.isRefreshing}
            onRefresh={logic.handleRefresh}
          />
        }
        onScroll={({ nativeEvent }) => {
          const { layoutMeasurement, contentOffset, contentSize } = nativeEvent;
          const isCloseToBottom =
            layoutMeasurement.height + contentOffset.y >= contentSize.height * LOAD_MORE_THRESHOLD;
          
          if (isCloseToBottom) {
            logic.handleLoadMore();
          }
        }}
        scrollEventThrottle={16}
      >
        {/* 4宫格分类区域 */}
        <CategoryArea
          unreadCounts={state.unreadCounts}
          onCategoryPress={logic.handleCategoryPress}
        />
        
        {/* 对话列表区域 */}
        <ConversationArea
          conversations={state.conversations}
          onConversationPress={logic.handleConversationPress}
          onConversationDelete={logic.handleConversationDelete}
          isLoading={state.isLoading}
        />
      </ScrollView>
    </View>
  );
};

// 样式定义
const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#FFFFFF',
  },
  scrollView: {
    flex: 1,
  },
});
// #endregion

// #region 9. Exports
export default MainPage;
export type { MainPageProps };
// #endregion
```

### 6.2 CategoryArea区域组件结构

```typescript
// #region 1. File Banner & TOC
/**
 * CategoryArea - 4宫格分类区域组件
 * 
 * 功能描述：消息分类入口，展示4个分类卡片和未读角标
 * 
 * TOC (快速跳转):
 * [1] Imports
 * [2] Types & Schema
 * [3] Constants & Config
 * [4] Utils & Helpers
 * [5] State Management
 * [6] Domain Logic
 * [7] UI Components & Rendering
 * [8] Exports
 */
// #endregion

// #region 2. Imports
import React, { useCallback } from 'react';
import { View, Text, TouchableOpacity, StyleSheet } from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';

import type { CategoryAreaProps } from './types';
import { CATEGORIES, UI_SIZES, COLORS, ANIMATION_DURATION } from './constants';
// #endregion

// #region 3. Types & Schema
interface CategoryCardProps {
  id: string;
  title: string;
  icon: string;
  color: string;
  unreadCount: number;
  onPress: () => void;
}
// #endregion

// #region 4. Constants & Config
const CARD_SIZE = UI_SIZES.CATEGORY_CARD_SIZE;
const ICON_SIZE = UI_SIZES.CATEGORY_ICON_SIZE;
// #endregion

// #region 5. Utils & Helpers
// 🎯 本地工具函数

/**
 * 格式化未读数量
 */
const formatUnreadCount = (count: number): string => {
  if (count === 0) return '';
  if (count > 99) return '99+';
  return count.toString();
};
// #endregion

// #region 6. State Management
// 无需状态管理（纯展示组件）
// #endregion

// #region 7. Domain Logic
// 🎯 事件处理函数

/**
 * 分类卡片点击处理
 */
const handleCategoryPress = (
  categoryId: string,
  onPress: (category: string) => void
) => {
  // 触觉反馈（移动端）
  // Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
  
  onPress(categoryId);
};
// #endregion

// #region 8. UI Components & Rendering
/**
 * 分类卡片组件
 */
const CategoryCard: React.FC<CategoryCardProps> = ({
  id,
  title,
  icon,
  color,
  unreadCount,
  onPress,
}) => {
  const handlePress = useCallback(() => {
    handleCategoryPress(id, onPress);
  }, [id, onPress]);
  
  return (
    <TouchableOpacity
      style={styles.card}
      onPress={handlePress}
      activeOpacity={0.7}
    >
      <LinearGradient
        colors={[color, color + 'CC']}
        style={styles.iconContainer}
      >
        {/* 图标 */}
        <Text style={styles.iconText}>{icon}</Text>
        
        {/* 未读角标 */}
        {unreadCount > 0 && (
          <View style={styles.badge}>
            <Text style={styles.badgeText}>
              {formatUnreadCount(unreadCount)}
            </Text>
          </View>
        )}
      </LinearGradient>
      
      <Text style={styles.title}>{title}</Text>
    </TouchableOpacity>
  );
};

/**
 * 分类区域组件
 */
const CategoryArea: React.FC<CategoryAreaProps> = ({
  unreadCounts,
  onCategoryPress,
  style,
}) => {
  return (
    <View style={[styles.container, style]}>
      <View style={styles.grid}>
        {CATEGORIES.map((category) => (
          <CategoryCard
            key={category.id}
            id={category.id}
            title={category.title}
            icon={category.icon}
            color={category.color}
            unreadCount={unreadCounts[category.id as keyof typeof unreadCounts] || 0}
            onPress={onCategoryPress}
          />
        ))}
      </View>
    </View>
  );
};

// 样式定义
const styles = StyleSheet.create({
  container: {
    paddingVertical: 16,
    paddingHorizontal: 16,
    backgroundColor: '#FFFFFF',
  },
  grid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'space-between',
  },
  card: {
    width: (CARD_SIZE + 16) * 2,
    marginBottom: 16,
    alignItems: 'center',
  },
  iconContainer: {
    width: CARD_SIZE,
    height: CARD_SIZE,
    borderRadius: 12,
    justifyContent: 'center',
    alignItems: 'center',
    position: 'relative',
  },
  iconText: {
    fontSize: ICON_SIZE,
  },
  badge: {
    position: 'absolute',
    top: -4,
    right: -4,
    backgroundColor: COLORS.UNREAD,
    borderRadius: 10,
    minWidth: 20,
    height: 20,
    justifyContent: 'center',
    alignItems: 'center',
    paddingHorizontal: 6,
  },
  badgeText: {
    color: '#FFFFFF',
    fontSize: 12,
    fontWeight: 'bold',
  },
  title: {
    marginTop: 8,
    fontSize: 14,
    color: COLORS.TEXT_PRIMARY,
  },
});
// #endregion

// #region 9. Exports
export default CategoryArea;
export { CategoryCard };
export type { CategoryAreaProps, CategoryCardProps };
// #endregion
```

---

## 🔄 七、状态管理策略

### 7.1 主文件集中管理（推荐）

消息模块的状态管理采用 **主文件集中管理** 策略，所有简单和中等复杂度的状态都在主文件内管理。

```typescript
// ✅ 正确做法：在主文件内直接管理所有状态

// #region 6. State Management
const useMainPageState = () => {
  // 数据状态
  const [conversations, setConversations] = useState<Conversation[]>([]);
  const [unreadCounts, setUnreadCounts] = useState<UnreadCounts>({...});
  
  // UI状态
  const [isLoading, setIsLoading] = useState(false);
  const [isRefreshing, setIsRefreshing] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  
  // 分页状态
  const [page, setPage] = useState(1);
  const [hasMore, setHasMore] = useState(true);
  
  // 计算属性
  const totalUnread = useMemo(() => {
    return Object.values(unreadCounts).reduce((sum, count) => sum + count, 0);
  }, [unreadCounts]);
  
  return {
    conversations,
    setConversations,
    unreadCounts,
    setUnreadCounts,
    isLoading,
    setIsLoading,
    isRefreshing,
    setIsRefreshing,
    error,
    setError,
    page,
    setPage,
    hasMore,
    setHasMore,
    totalUnread,
  };
};
// #endregion
```

### 7.2 WebSocket实时状态（复杂逻辑适度抽离）

对于WebSocket这种复杂的实时通信逻辑，可以适度抽离为独立Hook：

```typescript
// useWebSocket.ts - 复杂WebSocket逻辑抽离

/**
 * WebSocket连接管理Hook
 * 
 * 创建原因：
 * - 涉及复杂的连接状态管理
 * - 需要处理断线重连逻辑
 * - 多个页面需要共享WebSocket连接
 */
export function useWebSocket() {
  const [isConnected, setIsConnected] = useState(false);
  const [reconnectCount, setReconnectCount] = useState(0);
  const wsRef = useRef<WebSocket | null>(null);
  
  // 连接WebSocket
  const connect = useCallback(() => {
    if (wsRef.current) return;
    
    const ws = new WebSocket(WS_URL);
    
    ws.onopen = () => {
      setIsConnected(true);
      setReconnectCount(0);
    };
    
    ws.onclose = () => {
      setIsConnected(false);
      handleReconnect();
    };
    
    ws.onerror = (error) => {
      console.error('WebSocket error:', error);
    };
    
    ws.onmessage = (event) => {
      handleMessage(JSON.parse(event.data));
    };
    
    wsRef.current = ws;
  }, []);
  
  // 断线重连
  const handleReconnect = useCallback(() => {
    if (reconnectCount >= MAX_RECONNECT_ATTEMPTS) {
      return;
    }
    
    setTimeout(() => {
      setReconnectCount(reconnectCount + 1);
      connect();
    }, RECONNECT_INTERVAL);
  }, [reconnectCount, connect]);
  
  // 发送消息
  const sendMessage = useCallback((message: any) => {
    if (wsRef.current && isConnected) {
      wsRef.current.send(JSON.stringify(message));
    }
  }, [isConnected]);
  
  // 断开连接
  const disconnect = useCallback(() => {
    if (wsRef.current) {
      wsRef.current.close();
      wsRef.current = null;
    }
  }, []);
  
  useEffect(() => {
    connect();
    return () => disconnect();
  }, []);
  
  return {
    isConnected,
    sendMessage,
    disconnect,
  };
}
```

---

## 🚨 八、错误处理与边界情况

### 8.1 API错误处理

```typescript
/**
 * 统一API错误处理函数
 */
const handleApiError = (error: any): string => {
  if (error.code) {
    switch (error.code) {
      case 401:
        // 未授权：跳转登录页
        return '请先登录';
      case 403:
        // 权限不足
        return '权限不足，无法执行该操作';
      case 404:
        // 资源不存在
        return '内容不存在或已被删除';
      case 429:
        // 请求频繁
        return '操作过于频繁，请稍后再试';
      case 500:
        // 服务器错误
        return '服务器异常，请稍后重试';
      default:
        return '操作失败，请重试';
    }
  }
  
  if (error.message) {
    return error.message;
  }
  
  return '未知错误';
};

/**
 * 使用示例
 */
try {
  const response = await getConversationList({ page: 1, pageSize: 20 });
  if (response.code === 200) {
    setConversations(response.data.list);
  } else {
    const errorMessage = handleApiError(response);
    showToast(errorMessage);
  }
} catch (error) {
  const errorMessage = handleApiError(error);
  showToast(errorMessage);
}
```

### 8.2 空状态处理

```typescript
/**
 * 空状态组件
 */
const EmptyState: React.FC<{
  type: 'conversations' | 'likes' | 'comments' | 'followers' | 'notifications';
}> = ({ type }) => {
  const emptyMessages = {
    conversations: {
      icon: '💬',
      title: '暂无对话',
      subtitle: '开始和其他用户聊天吧',
    },
    likes: {
      icon: '💖',
      title: '暂无点赞和收藏',
      subtitle: '发布优质内容获得更多互动',
    },
    comments: {
      icon: '💬',
      title: '暂无评论',
      subtitle: '快去评论别人的作品吧',
    },
    followers: {
      icon: '👥',
      title: '暂无新增粉丝',
      subtitle: '提升内容质量吸引更多关注',
    },
    notifications: {
      icon: '🔔',
      title: '暂无系统通知',
      subtitle: '有新通知会第一时间告知您',
    },
  };
  
  const message = emptyMessages[type];
  
  return (
    <View style={styles.emptyContainer}>
      <Text style={styles.emptyIcon}>{message.icon}</Text>
      <Text style={styles.emptyTitle}>{message.title}</Text>
      <Text style={styles.emptySubtitle}>{message.subtitle}</Text>
    </View>
  );
};
```

### 8.3 加载状态处理

```typescript
/**
 * 加载状态组件
 */
const LoadingState: React.FC = () => (
  <View style={styles.loadingContainer}>
    <ActivityIndicator size="large" color={COLORS.PRIMARY} />
    <Text style={styles.loadingText}>加载中...</Text>
  </View>
);

/**
 * 错误状态组件
 */
const ErrorState: React.FC<{
  error: Error;
  onRetry: () => void;
}> = ({ error, onRetry }) => (
  <View style={styles.errorContainer}>
    <Text style={styles.errorIcon}>⚠️</Text>
    <Text style={styles.errorTitle}>加载失败</Text>
    <Text style={styles.errorMessage}>{error.message}</Text>
    <TouchableOpacity style={styles.retryButton} onPress={onRetry}>
      <Text style={styles.retryButtonText}>重试</Text>
    </TouchableOpacity>
  </View>
);
```

### 8.4 网络状态处理

```typescript
/**
 * 网络状态监听Hook
 */
const useNetworkStatus = () => {
  const [isOnline, setIsOnline] = useState(true);
  
  useEffect(() => {
    // 监听网络状态
    const unsubscribe = NetInfo.addEventListener(state => {
      setIsOnline(state.isConnected ?? false);
      
      if (!state.isConnected) {
        showToast('网络连接已断开');
      } else {
        showToast('网络已恢复');
        // 重新加载数据
      }
    });
    
    return () => unsubscribe();
  }, []);
  
  return { isOnline };
};
```

---

## ⚡ 九、性能优化实施方案

### 9.1 列表虚拟化

```typescript
import { FlatList } from 'react-native';

/**
 * 使用FlatList实现虚拟化列表
 */
const ConversationList: React.FC<{
  data: Conversation[];
  onItemPress: (id: string) => void;
}> = ({ data, onItemPress }) => {
  // 渲染单个列表项
  const renderItem = useCallback(({ item }: { item: Conversation }) => (
    <MessageItem
      id={item.id}
      type="conversation"
      avatar={item.userAvatar}
      title={item.userName}
      subtitle={item.lastMessage}
      timestamp={item.lastMessageTime}
      isRead={item.isRead}
      unreadCount={item.unreadCount}
      onPress={() => onItemPress(item.id)}
    />
  ), [onItemPress]);
  
  // 提取key
  const keyExtractor = useCallback((item: Conversation) => item.id, []);
  
  // 获取布局（性能优化）
  const getItemLayout = useCallback(
    (data, index) => ({
      length: UI_SIZES.MESSAGE_ITEM_HEIGHT,
      offset: UI_SIZES.MESSAGE_ITEM_HEIGHT * index,
      index,
    }),
    []
  );
  
  return (
    <FlatList
      data={data}
      renderItem={renderItem}
      keyExtractor={keyExtractor}
      getItemLayout={getItemLayout}
      initialNumToRender={10}
      maxToRenderPerBatch={10}
      windowSize={5}
      removeClippedSubviews={true}
    />
  );
};
```

### 9.2 图片懒加载

```typescript
import FastImage from 'react-native-fast-image';

/**
 * 优化的图片组件
 */
const OptimizedImage: React.FC<{
  uri: string;
  size: number;
  style?: any;
}> = ({ uri, size, style }) => (
  <FastImage
    source={{
      uri,
      priority: FastImage.priority.normal,
      cache: FastImage.cacheControl.immutable,
    }}
    style={[{ width: size, height: size }, style]}
    resizeMode={FastImage.resizeMode.cover}
  />
);
```

### 9.3 防抖节流

```typescript
import { useMemo } from 'react';
import { debounce, throttle } from 'lodash';

/**
 * 搜索输入防抖
 */
const useSearchDebounce = (callback: (keyword: string) => void, delay = 300) => {
  return useMemo(
    () => debounce(callback, delay),
    [callback, delay]
  );
};

/**
 * 滚动事件节流
 */
const useScrollThrottle = (callback: () => void, delay = 100) => {
  return useMemo(
    () => throttle(callback, delay),
    [callback, delay]
  );
};
```

### 9.4 数据缓存

```typescript
import AsyncStorage from '@react-native-async-storage/async-storage';

/**
 * 对话列表缓存
 */
const CACHE_KEY = 'MESSAGES_CONVERSATIONS_CACHE';

/**
 * 保存缓存
 */
const saveCache = async (data: Conversation[]) => {
  try {
    await AsyncStorage.setItem(CACHE_KEY, JSON.stringify(data));
  } catch (error) {
    console.error('保存缓存失败:', error);
  }
};

/**
 * 读取缓存
 */
const loadCache = async (): Promise<Conversation[]> => {
  try {
    const data = await AsyncStorage.getItem(CACHE_KEY);
    return data ? JSON.parse(data) : [];
  } catch (error) {
    console.error('读取缓存失败:', error);
    return [];
  }
};

/**
 * 清除缓存
 */
const clearCache = async () => {
  try {
    await AsyncStorage.removeItem(CACHE_KEY);
  } catch (error) {
    console.error('清除缓存失败:', error);
  }
};
```

---

## 📱 十、移动端特性适配

### 10.1 手势交互

```typescript
import { GestureDetector, Gesture } from 'react-native-gesture-handler';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withTiming,
  runOnJS,
} from 'react-native-reanimated';

/**
 * 滑动删除组件
 */
const SwipeableItem: React.FC<{
  children: React.ReactNode;
  onDelete: () => void;
}> = ({ children, onDelete }) => {
  const translateX = useSharedValue(0);
  
  const panGesture = Gesture.Pan()
    .onUpdate((event) => {
      // 只允许向左滑动
      if (event.translationX < 0) {
        translateX.value = event.translationX;
      }
    })
    .onEnd((event) => {
      // 滑动超过阈值触发删除
      if (event.translationX < -100) {
        translateX.value = withTiming(-200, { duration: 200 });
        runOnJS(onDelete)();
      } else {
        // 回弹
        translateX.value = withTiming(0, { duration: 200 });
      }
    });
  
  const animatedStyle = useAnimatedStyle(() => ({
    transform: [{ translateX: translateX.value }],
  }));
  
  return (
    <GestureDetector gesture={panGesture}>
      <Animated.View style={animatedStyle}>
        {children}
      </Animated.View>
    </GestureDetector>
  );
};
```

### 10.2 触觉反馈

```typescript
import * as Haptics from 'expo-haptics';

/**
 * 触觉反馈工具函数
 */
const hapticFeedback = {
  // 轻触反馈
  light: () => {
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
  },
  
  // 中等反馈
  medium: () => {
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
  },
  
  // 重触反馈
  heavy: () => {
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Heavy);
  },
  
  // 成功反馈
  success: () => {
    Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
  },
  
  // 警告反馈
  warning: () => {
    Haptics.notificationAsync(Haptics.NotificationFeedbackType.Warning);
  },
  
  // 错误反馈
  error: () => {
    Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);
  },
};

/**
 * 使用示例
 */
const handleButtonPress = () => {
  hapticFeedback.light();
  // 执行按钮操作
};
```

### 10.3 安全区域适配

```typescript
import { useSafeAreaInsets } from 'react-native-safe-area-context';

/**
 * 安全区域适配Hook
 */
const useMessagesLayout = () => {
  const insets = useSafeAreaInsets();
  
  return {
    // 顶部安全区域
    paddingTop: insets.top,
    
    // 底部安全区域
    paddingBottom: insets.bottom,
    
    // 导航栏总高度（含安全区域）
    navigationHeight: UI_SIZES.NAVIGATION_BAR_HEIGHT + insets.top,
    
    // 底部Tab栏总高度（含安全区域）
    tabBarHeight: UI_SIZES.BOTTOM_TAB_BAR_HEIGHT + insets.bottom,
  };
};

/**
 * 使用示例
 */
const MainPage: React.FC = () => {
  const layout = useMessagesLayout();
  
  return (
    <View style={{ flex: 1 }}>
      <View style={{ height: layout.navigationHeight, paddingTop: layout.paddingTop }}>
        {/* 导航栏内容 */}
      </View>
      
      <View style={{ flex: 1 }}>
        {/* 主内容 */}
      </View>
    </View>
  );
};
```

### 10.4 键盘处理

```typescript
import { KeyboardAvoidingView, Platform } from 'react-native';

/**
 * 键盘避让组件
 */
const ChatPage: React.FC = () => {
  return (
    <KeyboardAvoidingView
      style={{ flex: 1 }}
      behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
      keyboardVerticalOffset={Platform.OS === 'ios' ? 64 : 0}
    >
      {/* 聊天内容 */}
      <ScrollView>
        {/* 消息列表 */}
      </ScrollView>
      
      {/* 输入框固定底部 */}
      <View>
        <TextInput placeholder="输入消息..." />
      </View>
    </KeyboardAvoidingView>
  );
};
```

---

## 🧪 十一、测试策略

### 11.1 单元测试

```typescript
import { render, fireEvent, waitFor } from '@testing-library/react-native';
import MainPage from '../MainPage';

describe('MainPage', () => {
  it('应该正确渲染主页面', () => {
    const { getByText } = render(<MainPage />);
    expect(getByText('消息')).toBeTruthy();
  });
  
  it('应该正确处理分类点击', async () => {
    const { getByText } = render(<MainPage />);
    const likesCard = getByText('赞和收藏');
    
    fireEvent.press(likesCard);
    
    await waitFor(() => {
      // 验证导航跳转
    });
  });
  
  it('应该正确显示未读数量', () => {
    const { getByText } = render(<MainPage />);
    // 验证未读角标显示
  });
});
```

### 11.2 集成测试

```typescript
describe('Messages Integration', () => {
  it('应该完成完整的消息浏览流程', async () => {
    // 1. 进入消息主页
    // 2. 点击对话
    // 3. 查看消息详情
    // 4. 发送消息
    // 5. 返回主页
  });
});
```

---

## 📊 十二、监控指标

### 12.1 性能指标
- **首屏加载时间**: < 1s
- **列表滚动帧率**: >= 60fps
- **API响应时间**: < 500ms
- **内存占用**: < 200MB
- **WebSocket连接稳定性**: > 99%

### 12.2 业务指标
- **日活跃用户**: 监控
- **消息发送成功率**: > 99.5%
- **通知到达率**: > 95%
- **用户满意度**: 目标 4.5/5

### 12.3 质量指标
- **崩溃率**: < 0.1%
- **ANR率**: < 0.05%
- **接口成功率**: > 99.9%

---

## 📝 十三、实施检查清单

### ✅ 架构实施完整性检查

- [ ] **文件结构完整性**
  - [ ] 所有核心文件已创建（index/types/constants/README）
  - [ ] MainPage和SubPages结构正确
  - [ ] ComponentAreaName划分合理

- [ ] **前后端一体化完整性**
  - [ ] 前端API接口层文件完整
  - [ ] 后端实现层核心文件完整
  - [ ] 前后端数据类型定义一致
  - [ ] MyBatis-Plus配置正确

- [ ] **代码质量标准**
  - [ ] 所有主文件遵循八段式结构
  - [ ] 状态管理符合主文件优先原则
  - [ ] 类型定义完整无any
  - [ ] 常量全部提取无硬编码

- [ ] **功能完整性**
  - [ ] 核心功能实现完整
  - [ ] 错误处理覆盖全面
  - [ ] 边界情况处理完善
  - [ ] 性能优化已实施

- [ ] **文档完整性**
  - [ ] README文档完整
  - [ ] API文档清晰
  - [ ] 代码注释充分
  - [ ] 使用示例完整

---

## 🚀 十四、实施步骤

### 第一阶段：架构搭建（第1-2天）
1. 创建页面组根目录和核心文件
2. 定义完整的类型系统（types.ts）
3. 配置所有常量（constants.ts）
4. 编写架构文档（README.md）

### 第二阶段：前后端一体化实施（第3-5天）
5. 创建前端API接口层文件
6. 创建后端实现层所有文件
7. 配置MyBatis-Plus和QueryWrapper
8. 测试前后端数据交互

### 第三阶段：主页面实施（第6-8天）
9. 实施MainPage主页面
10. 实施NavigationArea导航栏区域
11. 实施CategoryArea分类区域
12. 实施ConversationArea对话列表区域

### 第四阶段：子页面实施（第9-12天）
13. 实施LikesPage赞和收藏页面
14. 实施CommentsPage评论页面
15. 实施FollowersPage粉丝页面
16. 实施NotificationsPage系统通知页面
17. 实施ChatPage私聊对话页面

### 第五阶段：优化与测试（第13-15天）
18. 性能优化实施
19. 单元测试和集成测试
20. 代码审查和重构
21. 文档完善和交付

---

## 📌 十五、注意事项

### 🚨 强制执行项
- ✅ 前后端必须同时完整交付
- ✅ 所有主文件必须遵循八段式结构
- ✅ 状态管理优先在主文件内集中
- ✅ 数据访问层统一使用MyBatis-Plus

### ⚠️ 避免的错误
- ❌ 仅创建前端接口而忽略后端实现
- ❌ 过度创建独立的hooks/utils文件
- ❌ 硬编码常量和魔法数字
- ❌ 过度设计未使用的接口

### 💡 最佳实践
- ✅ 按需设计，YAGNI原则
- ✅ 主文件完整自包含
- ✅ 代码可读性优先
- ✅ 持续重构优化

---

**版本**: v2.0  
**更新日期**: 2024年  
**基于标准**: UNIVERSAL_COMPONENT_ARCHITECTURE_CORE v2.5  
**适用范围**: XiangYuPai探店APP消息模块
