# 发现页面模块 - 实施前必读 ⚡

> **快速参考文档 - 5分钟掌握核心原则**
> 
> 基于：发现页面模块架构设计文档v2.0（强化版）

---

## 🚨 核心原则（3个必须牢记）

### 1️⃣ 主文件是王道

```
✅ 每个index.tsx都是完整、自包含的
✅ 所有逻辑都在八段式结构中
✅ 打开文件就能看到全部代码

❌ 不要跳转到其他文件才能理解
❌ 不要创建独立的Hook文件
❌ 不要创建独立的Utils文件
```

### 2️⃣ 八段式是框架

```typescript
// 任何主文件（index.tsx）都必须遵循：

// #region 1. File Banner & TOC
// #region 2. Imports
// #region 3. Types & Schema
// #region 4. Constants & Config

// #region 5. Utils & Helpers
// 🎯 所有工具函数放这里！不要创建utils文件！
const formatCount = (n) => { /* ... */ };
const formatTime = (t) => { /* ... */ };

// #region 6. State Management
// 🎯 所有状态放这里！不要创建useState Hook文件！
const [activeTab, setActiveTab] = useState('hot');
const [feedList, setFeedList] = useState([]);

// #region 7. Domain Logic
// 🎯 所有业务逻辑放这里！不要创建handler文件！
const handleTabChange = (tab) => { /* ... */ };
const loadData = async () => { /* ... */ };

// #region 8. UI Components & Rendering
// #region 9. Exports
```

### 3️⃣ 前后端要同步

```
✅ API接口 + 后端实现 = 一次性交付
✅ MyBatis-Plus + QueryWrapper = 标准技术栈
✅ 只创建前端实际需要的接口

❌ 不要只写前端API
❌ 不要过度设计（批量操作、管理员功能等）
```

---

## 🚫 绝对禁止创建的文件（背下来）

```
❌ useDiscoveryState.ts      - 状态必须在主文件第6段
❌ useMainPageData.ts         - 数据必须在主文件第6段
❌ usePublishFlow.ts          - 流程必须在主文件第7段
❌ useToggle.ts / useLoading.ts - 简单状态必须在主文件第6段

❌ utilsFormat.ts             - 格式化必须在主文件第5段
❌ utilsDisplay.ts            - 显示工具必须在主文件第5段
❌ utilsHelper.ts             - 辅助函数必须在主文件第5段
❌ utilsCalculate.ts          - 计算函数必须在主文件第5段

❌ processData.ts             - 数据处理必须在主文件第5段或第7段
❌ processValidation.ts       - 验证必须在主文件第7段
❌ processContent.ts          - 内容处理必须在主文件第7段

❌ onClickHandlers.ts         - 事件处理必须在主文件第7段
❌ eventHandlers.ts           - 事件处理必须在主文件第7段
```

---

## ⚠️ 允许例外的极少数情况

```
✅ utils/permissions.ts
   理由：设备权限请求，跨PublishPage、ProfilePage等多个页面使用
   示例：requestCameraPermission(), requestLocationPermission()

✅ utils/mediaCompress.ts
   理由：复杂图片/视频压缩算法，代码超过100行且完全独立
   示例：compressImage(), compressVideo()

✅ utils/mapSDK.ts
   理由：第三方地图SDK封装，需要统一管理配置
   示例：initMap(), getLocation()

⚠️ 注意：每次创建例外文件都必须有充分的注释说明理由！
```

---

## 📋 实施检查清单（5个核心检查）

### ✅ 检查1：主文件集中化

```
□ MainPage/index.tsx 是否包含所有状态？
□ MainPage/index.tsx 是否包含所有事件处理？
□ MainPage/index.tsx 是否包含所有工具函数？
□ 确认没有创建useMainPageState.ts？
□ 确认没有创建utilsFormat.ts？
```

### ✅ 检查2：八段式结构

```
□ 第5段是否包含所有工具函数？
□ 第6段是否包含所有状态管理？
□ 第7段是否包含所有事件处理？
□ 每段是否有#region标记？
□ 代码顺序是否严格按1-9段？
```

### ✅ 检查3：前后端一体化

```
□ 是否同时创建了API文件和后端实现？
□ Entity是否配置了MyBatis-Plus注解？
□ ServiceImpl是否使用QueryWrapper？
□ 接口是否只包含前端实际需要的？
□ 是否避免了过度设计（批量操作等）？
```

### ✅ 检查4：类型和常量

```
□ types.ts是否包含所有类型定义？
□ constants.ts是否包含所有常量？
□ 代码中是否没有硬编码？
□ 代码中是否没有any类型？
```

### ✅ 检查5：移动端特性

```
□ 是否处理了安全区域（useSafeAreaInsets）？
□ 是否处理了键盘（KeyboardAvoidingView）？
□ 列表是否使用了虚拟化（FlatList优化）？
□ 图片是否使用了懒加载？
```

---

## 🎯 实施示例对比

### ❌ 错误示例：过度拆分

```typescript
// ❌ 不要这样做！
// useMainPageState.ts
export function useMainPageState() {
  const [activeTab, setActiveTab] = useState('hot');
  return { activeTab, setActiveTab };
}

// utilsFormat.ts
export const formatCount = (count) => {
  if (count >= 10000) return `${(count / 10000).toFixed(1)}万`;
  return count.toString();
};

// MainPage/index.tsx
import { useMainPageState } from './useMainPageState';
import { formatCount } from './utilsFormat';

const MainPage = () => {
  const { activeTab, setActiveTab } = useMainPageState();
  // ...
};
```

### ✅ 正确示例：主文件集中

```typescript
// ✅ 应该这样做！
// MainPage/index.tsx
const MainPage = () => {
  // #region 5. Utils & Helpers
  const formatCount = (count: number) => {
    if (count >= 10000) return `${(count / 10000).toFixed(1)}万`;
    return count.toString();
  };
  
  const formatTime = (timestamp: number) => {
    const now = Date.now();
    const diff = now - timestamp;
    if (diff < 60000) return '刚刚';
    if (diff < 3600000) return `${Math.floor(diff / 60000)}分钟前`;
    return `${Math.floor(diff / 3600000)}小时前`;
  };
  // #endregion
  
  // #region 6. State Management
  const [activeTab, setActiveTab] = useState('hot');
  const [feedList, setFeedList] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [refreshing, setRefreshing] = useState(false);
  // #endregion
  
  // #region 7. Domain Logic
  const handleTabChange = useCallback((tab: string) => {
    setActiveTab(tab);
    loadFeedList(tab);
  }, []);
  
  const loadFeedList = async (tab: string) => {
    setIsLoading(true);
    try {
      const data = await apiDiscoveryMain.getFeedList({ tab });
      setFeedList(data.list);
    } catch (error) {
      Alert.alert('加载失败', error.message);
    } finally {
      setIsLoading(false);
    }
  };
  
  const handleRefresh = useCallback(async () => {
    setRefreshing(true);
    await loadFeedList(activeTab);
    setRefreshing(false);
  }, [activeTab]);
  // #endregion
  
  // #region 8. UI Components & Rendering
  return (
    <View style={styles.container}>
      <NavigationArea 
        activeTab={activeTab}
        onTabChange={handleTabChange}
      />
      <FlatList
        data={feedList}
        renderItem={({ item }) => (
          <FeedCard 
            feed={item}
            onLike={(id) => handleLike(id)}
          />
        )}
        onRefresh={handleRefresh}
        refreshing={refreshing}
      />
    </View>
  );
  // #endregion
};
```

---

## 🚀 实施顺序（8天计划）

```
Day 1：基础架构
  ✓ Discovery/index.tsx
  ✓ Discovery/types.ts
  ✓ Discovery/constants.ts
  ✓ 7个API文件骨架

Day 2：前后端一体化
  ✓ 9个Entity实体类
  ✓ 8个DTO/VO对象
  ✓ 15个Controller/Service/Mapper

Day 3-4：MainPage
  ✓ MainPage/index.tsx（完整八段式）
  ✓ NavigationArea/index.tsx
  ✓ ContentArea/index.tsx
  ✓ FeedCard/index.tsx

Day 5-7：6个SubPages
  ✓ DetailPage
  ✓ PublishPage（重点）
  ✓ TopicPage
  ✓ TopicSelectPage
  ✓ LocationSelectPage
  ✓ ReportPage

Day 8：优化和测试
  ✓ 虚拟列表优化
  ✓ 图片加载优化
  ✓ 缓存策略
  ✓ 完整测试
```

---

## ❓ 常见疑问 FAQ

### Q1: PublishPage的发布流程很复杂，真的不能抽离Hook吗？

**A**: 优先在主文件内实现！即使有50行状态和逻辑，也应该先放在主文件的第6段和第7段。只有当代码确实超过100行且完全独立时，才考虑抽离，并且必须有充分注释说明理由。

### Q2: formatCount这种工具函数每个页面都要用，不能抽离吗？

**A**: 不能！即使多个页面都用到，也应该在每个页面的主文件第5段定义。如果真的需要复用，可以在页面组级别的utils中定义（如Discovery/utils/format.ts），但必须有充分理由。

### Q3: 设备权限请求可以抽离，那媒体选择器呢？

**A**: 要看具体情况：
- ✅ requestCameraPermission() - 可以抽离，纯粹的权限逻辑
- ❌ useMediaPicker() - 不要抽离，包含状态管理，应在主文件内
- ⚠️ compressImage() - 如果算法超过100行，可以抽离

### Q4: 我看React官方文档都在推荐自定义Hook，为什么我们不能用？

**A**: 自定义Hook适用于跨项目复用的通用逻辑。但在我们的架构标准中，为了提高代码可维护性和可读性，要求主文件集中管理。这样可以：
- 减少文件跳转，提高开发效率
- 降低认知负担，新人更容易上手
- 避免过度抽象，保持代码简洁

---

## 📚 相关文档

- 📄 [发现页面模块架构设计文档v2.0.md](./发现页面模块架构设计文档v2.0.md) - 完整架构设计
- 📄 [发现页面模块架构设计文档v2.0-补充.md](./发现页面模块架构设计文档v2.0-补充.md) - 详细实施指南
- 📄 [UNIVERSAL_COMPONENT_ARCHITECTURE_CORE.md](../.cursor/rules/UNIVERSAL_COMPONENT_ARCHITECTURE_CORE.md) - 核心架构标准

---

**最后提醒**：实施前请仔细阅读完整的架构设计文档！本文档只是快速参考，完整的细节和示例请参考主文档和补充文档。

**开始实施前的最后确认**：
- ✅ 我已理解主文件优先原则
- ✅ 我已理解八段式代码结构
- ✅ 我已理解前后端一体化要求
- ✅ 我知道哪些文件绝对不能创建
- ✅ 我知道什么情况下才能创建例外文件

**祝实施顺利！🚀**
